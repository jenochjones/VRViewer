<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <title>WebXR with Controller Grabbing</title>
  <script src="https://unpkg.com/three@0.126.0/build/three.min.js"></script>
</head>
<body style="margin: 0; overflow: hidden;">
<button onclick="activateXR()" style="position: absolute; z-index: 1;">Start WebXR</button>

<script>
async function activateXR() {
  const canvas = document.createElement("canvas");
  document.body.appendChild(canvas);
  const gl = canvas.getContext("webgl", { xrCompatible: true });

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x202020);

  const cube = new THREE.Mesh(
    new THREE.BoxGeometry(0.2, 0.2, 0.2),
    [
      new THREE.MeshBasicMaterial({ color: 0xff0000 }),
      new THREE.MeshBasicMaterial({ color: 0x0000ff }),
      new THREE.MeshBasicMaterial({ color: 0x00ff00 }),
      new THREE.MeshBasicMaterial({ color: 0xff00ff }),
      new THREE.MeshBasicMaterial({ color: 0x00ffff }),
      new THREE.MeshBasicMaterial({ color: 0xffff00 })
    ]
  );
  cube.position.set(0, 0, -1);
  const sceneContainer = new THREE.Group();
  sceneContainer.add(cube);
  scene.add(sceneContainer);

  const camera = new THREE.PerspectiveCamera();
  camera.matrixAutoUpdate = false;

  const renderer = new THREE.WebGLRenderer({ canvas, context: gl });
  renderer.autoClear = false;

  const session = await navigator.xr.requestSession("immersive-vr", {
    optionalFeatures: ["local-floor", "hand-tracking", "bounded-floor"]
  });

  session.updateRenderState({
    baseLayer: new XRWebGLLayer(session, gl)
  });

  canvas.width = session.renderState.baseLayer.framebufferWidth;
  canvas.height = session.renderState.baseLayer.framebufferHeight;
  renderer.setSize(canvas.width, canvas.height, false);

  const referenceSpace = await session.requestReferenceSpace("local");

  // Add controller spheres
  const controllerSpheres = [];
  const controllers = [];
  const prevPositions = [];
  const isGrabbing = [];

  const controllerMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
  const controllerGeometry = new THREE.SphereGeometry(0.03, 16, 16);

  for (let i = 0; i < 2; i++) {
    const controller = renderer.xr.getController(i);
    const sphere = new THREE.Mesh(controllerGeometry, controllerMaterial.clone());
    sphere.material.color.setHSL(i * 0.5, 1, 0.5);
    controller.add(sphere);
    scene.add(controller);
    controllers.push(controller);
    controllerSpheres.push(sphere);
    prevPositions.push(new THREE.Vector3());
    isGrabbing.push(false);

    controller.addEventListener('selectstart', () => isGrabbing[i] = true);
    controller.addEventListener('selectend', () => isGrabbing[i] = false);
  }

  renderer.xr.enabled = true;
  renderer.xr.setSession(session);

  // Start XR frame loop
  const clock = new THREE.Clock();
  renderer.setAnimationLoop(() => {
    const delta = clock.getDelta();

    // For each controller: if grabbing, apply movement delta to scene
    for (let i = 0; i < controllers.length; i++) {
      const ctrl = controllers[i];
      const pos = new THREE.Vector3();
      ctrl.getWorldPosition(pos);

      if (isGrabbing[i]) {
        const deltaPos = new THREE.Vector3().subVectors(pos, prevPositions[i]);

        // Apply position delta as scene translation
        sceneContainer.position.add(deltaPos);

        // Optionally, rotate based on controller movement (basic gesture)
        const deltaRot = new THREE.Quaternion();
        deltaRot.setFromUnitVectors(
          prevPositions[i].clone().normalize(),
          pos.clone().normalize()
        );
        sceneContainer.quaternion.premultiply(deltaRot);
      }

      prevPositions[i].copy(pos);
    }

    renderer.render(scene, camera);
  });
}
</script>
</body>
</html>
